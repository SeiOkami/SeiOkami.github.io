---
title: (Не) Строгая типизация 1С
date: 2024-01-16 10:30:00 +/-TTTT
description: Статья на основе митапа по видами типизации кода в 1С
media_subpath: /assets/posts/2024-01-16-strict-typing-ones-article/
categories: [Статьи]
tags: [1С, Статьи]
image:
  path: 01.png
---

Существует множество языков программирования, и каждый имеет свои особенности по работе с типами данных. Слабые, явные, динамические и другие... Но кто же здесь 1С и почему с приходом "строгой" типизации EDT 1С-программистам стоит задуматься над изменением своих привычек.

Данная статья является текстовым вариантом внутреннего митапа компании Магнит

Посмотреть видео-запись можно здесь: TODO: Плеер видео

Существует множество языков программирования, и каждый имеет какие-то особенности по работе с типами. В том числе и наша любимая 1С.

Но в целом мы можем их разделить на какие-то общепринятые виды типизации языков программирования

![Языки программирования](01.png)

Виды типизации языков программирования

| Статическая | Динамическая |
| Сильная     | Слабая       |
| Явная       | Неявная      |

Но кто же здесь 1С и почему с приходом "строгой" типизации EDT 1С-программистам стоит задуматься над изменением своих привычек.

Все примеры кода из статьи специально упрощены для облегчения понимания. Когда в примере есть заведомо бессмысленный код наподобие А = 2 * "20", то стоит понимать, что подразумевается, что в выражении используются реальные переменные, со значениями которых мы работаем.

# Статическая и Динамическая

* **Статическая типизация** - переменная имеет конкретный один тип и изменить этот тип она не может.
Мы создаём переменную, назначаем ей тип Cat. Создаётся ячейка памяти (грубо говоря, коробочка) куда мы можем поместить только котика и ничего больше.

Это проверяется на уровне компиляции и если мы попытаемся поместить туда кого-то другого, то мы не сможем даже запустить такую программу.

* **Динамическая типизация** - переменная может содержать любой тип.
Можно сказать так, что тип имеет конкретное текущее значение переменной, а не она сама. И в любой момент времени тип значения в переменной может измениться. И в нашей коробочке под названием "Кот" окажется крокодил.

![Статическая и Динамическая](02.png)

TODO: пояснение выделить
Да, в 1С мы можем назначить конкретный тип реквизиту (например, Сумма - Число). Но стоит понимать, что это только частично защищает от потенциальных проблем. Ведь ни Конфигуратор, ни Предприятие не укажут на ошибку в случаях, когда мы попытаемся в этот числовой реквизит поместить, например, массив. 1С лишь попытается привести переданный тип к типу реквизита.

## Сильная и слабая

* **Сильная (строгая) типизация** - операции между разными типами данных запрещены.
* **Слабая (нестрогая) типизация** - позволяют проводить операции между разными типами данных
Например, такая операция в 1С будет выполняться.

```bsl
Сообщить(ТекущаяДата() - 5 * "2");
```

При этом существуют языки программирования с сильной (строгой) типизацией, в которых подобные операции будут запрещены и выявляться компилятором ещё до выполнения программы.

![Сильная и слабая](03.png)

## Явная и неявная

* **Явная типизация** - указание типа обязательно
* **Неявная типизация** - тип можно не указывать

А вот явная и неявная типизация - это такой маленький нюансик, описывающий необходимость явного указания типа. Или же тип мы просто не указываем и он определяется автоматически по контексту.

В явной типизации каждая переменная должна быть объявлена с явным указанием типа.

![Явная и неявная](04.png)

## Нюансы классификаций

Любой язык программирования можно отнести к одному или другому виду по этим вариантам классификаций. Но на самом деле, не всё так однозначно.

Например, C# является языком со статической типизацией. Но при этом, он предоставляет особый тип dynamic, который является по сути возможностью использования динамической типизации.

Так же C# хоть и требует явное указание типа переменной (переменная без типа не может быть создана), но даёт ещё и ключевое слово var, которое можно поставить вместо типа и компилятор сам будет его определять. Если мы вызываем метод, который возвращает только строку, то компилятор поймёт, что переменная может быть только строкового типа и сам этот тип объявит при компиляции кода.

Таким образом, один язык может обладать свойствами обеих сторон типизации. Но всё же в большей степени относится к одному из них.

Подробнее можно прочитать, например, в старенькой статье на Хабре: [Ликбез по типизации в языках программирования](https://habr.com/ru/articles/161205/)

## «Требовательные» и «Дозволительные»

Все эти виды классификации мы можем дополнительно обозначить как «Требовательные» (которые больше требуют от разработчика) и «Дозволительные» (которые больше позволяют программисту "свобод").

![«Требовательные» и «Дозволительные»](05.png)

В плюсы "требовательных" ЯП можно отнести:

* **Скорость выполнения**. В статической типизации на переменную выделяется память заранее известного размера. И отсутствуют разного рода "неявные" преобразования типов, когда, например, строковое значение платформа пытается поместить в числовой реквизит, проводя анализ её содержимого.
* **Надёжность**. Из-за указания типов появляется возможность использовать множество дополнительных проверок в среде разработки и на этапе компиляции. Разработчик не передаст случайно в метод "неправильный тип" и не перепутает переменную. В динамической же типизации множество ошибок приходится отлавливать уже в процессе выполнения программы.
* **Скорость сложной разработки**. Чем больше проект, чем больше кода и метаданных, тем проще допустить какую-то ошибку. От этого нас оберегают множество проверок на этапе компиляции.

Но и "дозволительные" имеют свои преимущества:
* **Легкость освоения**. Начинающему программисту проще писать код, когда можно меньше задумываться о типах и операций над ними. Тем более, когда и сама система типов упрощена и в 1С, к примеру, все числовые типы "обычных" языков программирования объединены в просто "Число".
* **Краткость**. Меньше букоффф, проще текст) Не нужно указывать типы ни для переменных, ни для параметров, ни для результатов метода. Не нужно дополнительно приводить типы к другим, ведь платформа часто сама это может сделать.
* **Скорость простой разработки**. Сделать срочно простенький отчет, обработку или печатную форму проще. Можно упрощать код универсальными коллекциями (массивами со всем подряд) и так далее.

## Экосистема 1С
![Экосистема 1С](06.png)
Экосистема 1С постепенно пополняется новыми языками и системами.
* 1С:Исполнитель
* 1С:Элемент

Созданные на их основе
* 1С:Шина
* 1С:Аналитика
* ...

Все эти части нового мира 1С используют статическую типизацию, и лишь дополнительно поддерживает динамический подход.

А вот [по этой ссылке](https://its.1c.ru/db/pubelementlang#content:19:hdoc) можно прочитать обоснование почему 1С в языке Элемент отошла от динамической типизации и рекомендует использование статической.

TODO: спойлер сделать
![Экосистема 1С](07.png)

## 1С - динамическая, слабая и неявная типизация

Наша любимая 1С относится к динамической, слабой (нестрогой) и неявной типизации.

![1С - динамическая, слабая и неявная типизация](08.png)

* **Типы переменных объявлять не нужно**. По сути тип есть только у текущего значения переменной, а не у неё самой.
* **Меняем тип в любой момент**. Лень придумывать имя для новой переменной? А зачем? Можно ведь просто перезаписать старую.
* **Можем сложить любой тип с любым**. Глядишь, что-то из этого и получится. Особенно это удобно при построении текста сообщения, когда не нужно писать лишние "Строка()".
* **Можем передать что угодно куда угодно**. Даже если это платформенный метод. Иногда это даже открывает новые недокументированные возможности, о чём я писал в статье.

Но у такого (казалось бы идеального) подхода есть и свои недостатки:  

![1С - динамическая, слабая и неявная типизация](09.png)

* **Никогда не знаешь, что к тебе прилетит**. Кто мешает в твой параметр с именем Массив передать ссылку на справочник? Проблему усугубляет то, что эту переменную случайно кто-то перезатёр в закоулках кода и текст ошибки никак не поможет это выяснить. 
* **Нужно проверять типы самому**. Да, в БСП есть удобные методы для этого. Но что если твой универсальный метод может принимать не один-два конкретных типа? Например, мы пишем метод, который перебирает входящую в параметр коллекцию и возвращает порцию N элементов. Нам без разницы какого типа эта коллекция. Главное, чтобы она имела метод Количество() и её элементы можно было перебрать циклом. 1С лишена возможностей, которые есть в статических языках. Например, интерфейсов, благодаря которым мы могли бы просто проверить параметр на интерфейс "Коллекция".
* **Легко случайно что-то перепутать**. Конфигуратор не проверяет типы, которые вы присваиваете или передаёте в методы. Предприятие зачастую тоже. Да и что проверять, если переменные типов-то и не имеют?)
* **Об ошибке узнаешь уже на проде**. Причём не всегда сразу. Может оказаться, что при конкретной комбинации действий где-то в мешанине нашего кода переменная случайно затирается другим типом, а потом попадает в реквизит документа, из-за чего его значение оказывается пустым или некорректным. И узнаем мы о таких исключительных ситуациях, когда они уже значительно накопятся. И будем снова изучать код в отладке.

Потому программист 1С со временем учится "компилировать" код в уме. Смотреть на метод и "догадываться" где и как можно было случайно что-то сломать.

Но тут на сцену врывается EDT...

## Автоматический расчет типов EDT

![Автоматический расчет типов EDT](10.png)

EDT "из коробки" имеет автоматический расчет типов.

* **Определение типов и свойств**. Типы переменных, параметров. Свойства структур и колонки таблиц. Всё это IDE рассчитывает сама, основываясь на иерархии вызовов.
* **Контекстная подсказка типов и свойств**. Благодаря предыдущему пункту разработчику теперь не нужно использовать разные хитрости, чтобы заставить конфигуратор понять какого типа у нас переменная. EDT делает это автоматически. Ещё и понимает, например, какие есть свойства в прилетевшей нам структуре.
* **Отслеживание изменений типов и свойств**. Например, сначала переменная была массивом, а потом через несколько строк кода её затёрли строкой. EDT это отслеживает.
* **Переменные, свойства, параметры, результаты функций и так далее.**

Но что если автоматического анализа не хватает? Ведь EDT не идеальна...

* **Избыточные типы**. Например, из универсальных методов, которые есть и в платформе и в БСП. Методы, которые в зависимости от входящих параметров могут вернуть разные типы значений. В таких случаях EDT не знает какой конкретно тип вернётся, поэтому запоминает все возможные.
* **Извлечение хранилища**. Это пример максимально не типизированного метода самой платформы. Среда разработки не может понять, что в хранилище будет находиться во время выполнения кода, а значит и тип определить не может. Такие переменные будут "Произвольные".
* **Неявные создания**. Когда мы, например, создаем структуру, передавая имена ключей через переменную. 
* **Неявные обращения**. Когда вместо "Структура.Свойство" мы обращаемся опять же через переменную "Структура[ИмяСвойства]".
* **Результаты запросов**. Запросы и так бывают очень сложные, так ещё и "собираемые" из кусочков. И кто вообще знает что там будет в результате?)

И получается, что вроде как у нас есть EDT, которая автоматически рассчитывает типы и свойства, но при этом множество мест, где сделать это не предоставляется возможным. Как же разработчику помочь среде разработки помогать ему разрабатывать?